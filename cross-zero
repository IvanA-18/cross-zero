//подключение библиотек

#include <iostream> //ввод-вывод
#include <cstdlib> //настройки консоли и генератор случайных чисел
#include <string> //для работы со строками
#include <windows.h> //для использования Sleep() 

using namespace std; // стандартное пространство имен

	// Стартовая функция для вывода основной информации

void start()
{
	cout << endl << "LAPTOP_AGRO: 'Ты смел, если решишься играть со мной! Уверен ли ты, что у тебя есть шансы против вычислительной машины?!'";
	cout << endl << endl; 
	cout << "LAPTOP_AGRO: 'Если все же готов сыграть - нажиамай enter'" << endl;
	system("pause > nul"); // ожидаем, пока пользователь запустит игру

	// Выводим в % загрузку игрового поля со случайной задержкой по времени для реалистичности

	cout << endl << endl << "Загрузка поля: " << endl;
	srand(time(NULL));
	int i, k; double time_l;
	for (i = 0; i < 10; i++)
	{
		cout << i * 10 << "%" << "_";
		time_l = 0 + rand() % 2;
		Sleep(time_l * 1000); // задержка по времени в мс, 0 <= time_l <= 2
	}
	cout << "100%" << endl; // последняя ступень загрузки
	cout << endl << "Игровое поле загружено." << endl;

	// Задаем и выводим матрицу 3*3, заполненную символами "-", реализующую игровое поле

	const int n = 3;
	int number = 9 * n - 4;
	int j; char area[n][n];
	for (i = 0; i < number - 2; i++)
		cout << "_";
	cout << endl;
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < n; j++)
		{
			area[i][j] = '-';
			cout << "| " << area[i][j] << " |	";
		}
		cout << i + 1 << endl;
		for (k = 0; k < number - 2; k++)
			cout << "_";
		cout << endl;
	}
	for (j = 0; j < n; j++)
		cout << "  " << j + 1 << "	";
	cout << endl;
	cout << endl << "Для выбора клетки введите, сначала, номер строки, а затем номер столбца, например: 1 2. Чтобы сдаться - введите: 0 0" << endl; //инструкция для пользователя
}

	//функция, отвечающая за новую игру и выход

int gameover( int replay_exit) // запрашиваем действие от пользователя и в зависимости от результата возвращаем 1 или 0
{
	while (TRUE) // задаем цикл для проверки на недопустимое значение. Если значение корректно - возвращаем 1 или 0 и выходим из него
	{
		if (replay_exit == 0)
		{
			return 0;
			break;
		}
		else 
			if (replay_exit == 1)
			{
				return 1;
				break;
			}
			else
			{
				cout << "Недопустимое значение!" << endl; 
				cout << "Выберите действие: "; cin >> replay_exit;
			}
	}
}

	//Функция, реализующая игру

void game()
{

	//блок задания переменных

	int draw_count = 0; // счетчик для ничьей
	const int m = 3; // размер поля
	char area[m][m]; // матрица, задающая поле
	int i, j, k; // счетчики
	string player_name; // Ник игрока
	int replay_ex; // переменная для вызова gameover()
	int mot, simbl_p; // переменные для очереди хода и случайного выбора символа 
	char simbol[2] = { 'x', '0' }, simb; // массив из 2 - х символов - x и 0, символ, которым ходит игрок / компьютер
	int score[2] = {0, 0}; // массив для проверки исхода игры
	int win_lose[16], z, win; bool stop = 1, lose = 0; // переменные для проверки выигрыша или сдачи. для проверки выигрыша будем использовать массив из 16 нулей
	mot = 0 + rand() % 10; // генерируем целое число в промежутке от 0 до 10, чтобы разыграть очередь хода. если оно четно - ходит человек, иначе - компьютер. 
	//потом эта переменная будет принимать значения 1 и 0
	cout << endl << "Введите ваше имя: "; cin >> player_name; // спрашиваем ник
	simbl_p = 0 + rand() % 2; // генерируем целое число в промежутке от 0 до 1 для жеребьевки символов
	simb = simbol[simbl_p]; // определяем символ для того, кто ходит первым

	//обнуляем массив

	for (z = 0; z < 16; z++) 
		win_lose[z] = 0;
	
	//проверяем, кто ходит первым и каким символом, выводим некоторую информацию.

	if (mot % 2 == 0)
	{
		cout << "Первым ходит " << player_name << endl;
		cout << "Вам достались " << simb << endl;
	}
	else
	{
		cout << "Первым ходит LAPTOP_AGRO" << endl;
		cout << endl << "LAPTOP_AGRO: 'Ну что ж, первый ход за мной. Удачи, " << player_name << "!'" << endl;
		cout << "В этот раз мне выпали " << simb << endl;
	}

	// заполняем матрицу символом "-"

	int number = 9 * m - 4;
	int a, b;
	for (i = 0; i < m; i++)
		for (j = 0; j < m; j++)
			area[i][j] = '-';

	//начало игры. для того, чтобы игрок и компьютер ходили по очереди, пока не наступит тот или иной исход - используем бесконечный цикл

	while (TRUE)
	{
		
		//Если первым ходит игроок

		if (mot % 2 == 0)
		{
			mot = 0; // понадобится для проверки. как было описано выше, эта переменная будет принимать значения 0 и 1
			while (TRUE)
			{
				cout << endl << player_name << ", выбирайте клетку: "; cin >> a >> b; //запрашиваем данные клетки от игрока
				if ((a == 0) && (b == 0)) // если получили 0 0 -> игрок сдался, поэтому сразу выходим из цикла, в дальнейшем есть проверка этого случая
				{
					lose = 1; // логическая перменная, изначально равна 0 по умолчанию. значение меняется, когда игрок сдается
					break;
				}

				//проверяем введенные данные на корректность в бесконечном цикле

				if ((a < 1) || (b < 1) || (a > 3) || (b > 3)) 
				{
					while (TRUE)
					{
						cout << "Введено недопустимое значение!" << endl; // в случае некорректного ввода выдаем ошибку
						cout << endl << player_name << ", выбирайте клетку: "; cin >> a >> b; // запрашиваем значение заново
						if (((a >= 1) && (a <= 3)) && ((b >= 1) && (b <= 3))) // если значение корректно - выходим из цикла
							break;
					}
				}

				//проверяем, свободна ли выбранная клетка. если да, то в ней будет "-"

				if (area[a - 1][b - 1] == '-') 
				{
					area[a - 1][b - 1] = simb; // записываем в клетку символ и выходим из цикла, если она свободна
					break;
				}
				else
					cout << "Эта клетка занята, выберите другую!" << endl; // выдаем сообщение и запрашиваем значение снова, если клетка занята(произойдет возврат в начало цикла)
			}
		}

		// блок, где опишем ход компьютера

		else
		{
			Sleep(1600); // задержка по времени перед ходом машины
			while (TRUE) // в бесконечном цикле генерируем значение клетки. это важно, чтобы найти незанятую клетку
			{

				//генерация номера строки и столбца соответственно

				a = 0 + rand() % 3; 
				b = 0 + rand() % 3;

				// проверка, свободна ли клетка. если да, записываем значение и выходим из цикла. если нет - генерируем новую(возврат в начало цикла)

				if (area[a][b] == '-') 
				{
					area[a][b] = simb;
					break;
				}
			}
		}

		//выводим обновленное поле после сделанных ходов

		for (i = 0; i < number - 2; i++)
			cout << "_";
		cout << endl;
		for (i = 0; i < m; i++)
		{
			for (j = 0; j < m; j++)
			{
				cout << "| " << area[i][j] << " |	";
			}
			cout << i + 1 << endl;
			for (k = 0; k < number - 2; k++)
				cout << "_";
			cout << endl;
		}
		for (j = 0; j < m; j++)
			cout << "  " << j + 1 << "	";

		//проверим, нет ли ничьей следующим образом: будем считать количество клеток, занятых крестиком или ноликом, то есть не равных "-". Если их 9, но при этом не выполнится ни одна из 
		//дальнейших проверок на исход игры, то это и будет условием ничьей. Поэтом при встрече такой клетки - применяем инкремент переменной draw_count.
		//важно помнить, что необходимо в конце после каждой проверки обнулять переменную draw_count

		for (i = 0; i < m; i++)
		{
			for (j = 0; j < m; j++)
			{
				if (area[i][j] != '-')
					draw_count++;
				else
					break;
			}
		}
		cout << endl << endl;

		/*блок проверки на исход того, что кто - то выиграл.важным моментом будет являться, что ноликам будут соответствовать нечетные номера элементов ранее заданного массива win_lose, а
		крестикам - четные. также в соответствие каждому элементу поставим один из 16 - ти случаев, при котором выигрыш будет, когда в одной из 3 - х строк по вертикали, или одной из 
		3-х строк по горизонтали, или же одной из диагоналей будет содержаться набор из 3 - х крестиков или 3 - х ноликов. Напомним, что ходу человека соответствует mot = 0, клмпьютера - mot = 1
		имея эти данные, мы сможем оценить, кто выиграл, а кто проиграл. если же игра еще не закончена, нам необходимо обнулить массив, чтобы начать в следующий раз проверку заново
		элемнетам с номерами 0 и 14, 1 и 15, поставим в соответствие главную и побочную диагонали, по крестикам и ноликам соответственно. элементам с номерами 2, 4, 6 и 3, 5, 7 - первую, вторую и
		третью строку по крестикам и ноликам соответственно, а элементам 8, 10, 12 и 9, 11, 13 - первый, второй и третий столбец по крестикам и ноликам соответственно. 
		в каждую переменную будем прибавлять 1 при обнаружении хотябы 1 - го крестика или 1-го нолика в строке, столбике или диагонали. как только одна из них станет равна 3, мы можем сказать о
		выигрыше, а поэтому дальнейшую проверку не проводить. необходимо будет запомнить номер элемента, оценить его четность, а после проверить, кто выиграл, после чего увеличив на 1 элемент score[1],
		если выиграл компьютер или score[0], если выиграл игрок массива score[2] = {0, 0}. после поменять значение логическрй переменной stop с 1(по умолчанию) на 0, которая является точкой завершения 
		цикла*/

		for (i = 0; i < m; i++)
		{
			for (j = 0; j < m; j++)
			{
				if (i == j)
				{
					if (area[i][j] == 'x')
						win_lose[0] += 1;
					else
						if (area[i][j] == '0')
							win_lose[1] += 1;
				}
				if (i == 0)
				{
					if (area[i][j] == 'x')
						win_lose[2] += 1;
					else
						if (area[i][j] == '0')
							win_lose[3] += 1;
				}
				if (i == 1)
				{
					if (area[i][j] == 'x')
						win_lose[4] += 1;
					else
						if (area[i][j] == '0')
							win_lose[5] += 1;
				}
				if (i == 2)
				{
					if (area[i][j] == 'x')
						win_lose[6] += 1;
					else
						if (area[i][j] == '0')
							win_lose[7] += 1;
				}
				if (j == 0)
				{
					if (area[i][j] == 'x')
						win_lose[8] += 1;
					else
						if (area[i][j] == '0')
							win_lose[9] += 1;
				}
				if (j == 1)
				{
					if (area[i][j] == 'x')
						win_lose[10] += 1;
					else
						if (area[i][j] == '0')
							win_lose[11] += 1;
				}
				if (j == 2)
				{
					if (area[i][j] == 'x')
						win_lose[12] += 1;
					else
						if (area[i][j] == '0')
							win_lose[13] += 1;
				}
				if (j == m - 1 - i)
				{
					if (area[i][j] == 'x')
						win_lose[14] += 1;
					else
						if (area[i][j] == '0')
							win_lose[15] += 1;
				}
			}

			//цикл для проверки, не нашлось ли элемента win_lose, равного 3

			for (z = 0; z < 16; z++)
			{
				if (win_lose[z] == 3)
				{
					win = z; // запоминаем номер, если нашли такой элемент
					stop = 0; // изменяем значение логической переменной
					if (((win % 2 == 0) && (mot == 0) && (simb == 'x')) || ((win % 2 != 0) && (mot == 0) && (simb == '0'))) //проверка выигрыша человека
					{
						score[0] = 1;
					}
					if (((win % 2 == 0) && (mot == 1) && (simb == 'x')) || ((win % 2 != 0) && (mot == 1) && (simb == '0'))) //проверка выигрыша компьютера
					{
						score[1] = 1;
					}
				}
			}
			if (stop == 0) // выходим из цикла, если stop переключилась
				break;
		}

		/*Важным моментом является изменение очереди хода. Например, если первым ходил компьютер ноликами, то mot = 1, simb = '0'. Человек же тогда должен ходить крестиком, и нам важно помнить,
		кто последним сделал ход, иначе значение переменной mot, поэтому мы будем их чередовать после каждого сделанного хода. если simb = 'x', заменим simb = '0', иначе наоборот simb = '0'. 
		аналогичено с mot. если mot = 0 - заменим mot = 1, иначе заменим - mot = 0*/
		
		if (simb == 'x')
			simb = '0';
		else
			simb = 'x';
		if (mot == 0)
			mot = 1;
		else
			mot = 0;
		
		//обнулим, как было сказано прежде, массив проверки выигрыша win_lose

		for (z = 0; z < 16; z++)
			win_lose[z] = 0;

		/*теперь необходимо оценить результат игры. мы получили все необходимые данные. если score[0] = 1, значит выиграл человек, поэтому выводим соответствующие сообщения, при этом обнулив draw_count.
		это важно сделать, так как может сложиться ситуация, в которой выигрыш наступает после заполнения последней 9 -й клетки, из-за чего может быть выведена лишняя информация. если score[1] = 1, 
		значит выиграл компьютер, поэтому анадлогично выводим соответствующее сообщение. если же ни одно условие не выполнено, но при этом draw_count = 9, значит игра завершилась ничьей. выдаем 
		соответствующее сообщение. осталось проверить последний исход. если значение переменной lose поменялось с 0 на 1, то значит игрок сдался, и необходимо вывести соответствующее сообщение*/
		
		// проверка выигрыша человека

		if (score[0] == 1)
		{
			cout << endl << "Победил " << player_name << ". Поздравляем!" << endl;
			cout << "LAPTOP_AGRO: 'Поразительно! Как тебе это удалось?! Похоже, ты действительно умен!'" << endl;
		}
		
		//проверка выигрыша компьютера

		if (score[1] == 1)
		{
			cout << endl << "Победил LAPTOP_AGRO. Поздравляем!" << endl;
			cout << endl << "LAPTOP_AGRO: 'Твое поражение закономерно! Куда вам людишкам тягаться с моими вычислительными способностями!'" << endl;
			
		}

		//проверка ничьей

		if (draw_count == 9)
			{
				cout << endl << "Ничья! Победила дружба!" << endl;
				cout << "LAPTOP_AGRO: 'У тебя почти получилось! Ну ничего, в следующий раз повезет!'" << endl;
			}

		//проверка сдачи

		if (lose == 1)
			{
				cout << player_name << " сдался." << endl;
				cout << "LAPTOP_AGRO: 'Ты слаб, раз признаешь свое поражение!'" << endl;
			}

		/*не исключено, что пользователь захочет сыграть еще раз, поэтоу предусмотрим это в программе. в данном блоке будет лишь выведено сообщение с предложением выбрать одну из двух комманд
		0 - чтобы выйти, 1 - сыграть еще раз. сам перезапуск будет реализован вызовом gameover(). сообщение необходимо выводить в случае одного из исходов, описанных выше: победа игрока или 
		компьютера, ничья, сдача*/
		
		//проверяем, выполнен ли хотя бы один из исходов, и, если да - выводим сообщение

		if ((score[0] == 1) || (score[1] == 1) || (draw_count == 9) || (lose ==1))
		{
			cout << endl << "Игра окончена. Вы можете выбрать одно из следующих действий: " << endl << "1 - чтобы сыграть еще раз" << endl << "0 - чтобы выйти" << endl;
			break;
		}

		draw_count = 0; //обнуляем счетчик ничьей, про что говорилось ранее!

	}
}

	//вызов функций start() -> game() -> gameover() будет поочередно осуществляться в функции main(void)

int main(void)
{
	system("chcp 1251 > nul"); // устанавливаем настройки консоли
	int repl_ex; // переменная для вызова gameover()
	system("cls"); // очистка консоли
	cout << "Вашему вниманию представлены крестики-нолики" << endl; // стартовое сообщение

	//вызов функций

	start(); // вызываем функцию start(), которая запускает игру и генерирует поле и инструкции
	game(); // вызываем функцию game(), отвечающую за игровой процесс

	/*после того, как функция game() завершит работу, то на экран будет выведен текст с предложением выбрать одно из двух действий, в зависимости от которых необходимо или перезапустить игру, 
	или выйти. За это отвечает функция gameover(), которая принимает в качестве аргумента целое число. поэтому необхожимо спросить пользователя, какое он действие выберет и передать ответ gameover()*/

	cout << endl << "Выберите действие: "; cin >> repl_ex; //запрос действия от пользователя
	gameover(repl_ex);// вызов gameover()

	/*теперь функция gameover вернет 0 или 1. в случае 1 игра начинается сначала, причем это может повторяться неограниченное количество раз, а в случае 0 программа завершится. для реализации 
	воспользуемся бесконечным циклом, в котором будут вызываться заново функции start() и game(), после работы которых у пользователя вновь спросят, что он хочет сделать, и если он выберет выход,
	цикл будет завершен*/

	//задаем бесконечный цикл

	while (TRUE)
	{

		//оцениваем значение, которое вернула gameover()

		if (gameover(repl_ex) == 0) //прекращаем цикл, если возвращаемое значение 0
			break;
		
		//если возвращаемое значение не 0

		else
		{
			system("cls"); // очищаем консоль
			cout << "LAPTOP_AGRO: 'Ну что ж, давай попробуем еще разок!'"; // реплика в случае переигрывания
			start(); // вызываем start()
			game(); // вызываем game()
			cout << endl << "Выберите действие: "; cin >> repl_ex; // запрос от пользователя действия по результату работы функций
			gameover(repl_ex); //очередной вызов gameover()
		}
	}
	cout << endl;

	system("pause");// удержание консоли

	return 0; // значение, возвращаемое функцией main(void)

}
